#ifndef UNIT_TEST
#include <Arduino.h>
#include "Platform/Arduino/Logging/ArduinoSerialLogger.h"
#include "Platform/Arduino/Providers/ArduinoTimeProvider.h"
#include "Contracts/Logging/Log.h"
#include "Contracts/Providers/Time.h"
#include "Contracts/Connections/WiFiManager.h"

#include "Contracts/Transports/IMqttClient.h"
#include "Core/Services/MqttService.h"
#include "Platform/Espressif/Mqtt/EspIdfMqttClient.h"
#include "Core/Sinks/MqttSink.h"
#include "Contracts/Events/CapabilityStateChanged.h"
#include "Contracts/Capabilities/LightCapability.h"
#include "Contracts/Capabilities/PushButtonCapability.h"
#include "Platform/Arduino/Adapters/RelayHardwareAdapter.h"
#include "Platform/Arduino/Adapters/InputHardwareAdapter.h"

#include "Platform/Espressif/Pinouts/ESP32_S3_Pinouts.h"

// ---- Optional SettingsManager integration (API = source of truth, NVS = redundancy) ----
#if __has_include("Contracts/Settings/SettingsManager.h") && \
    __has_include("Contracts/Settings/ISettingsFetcher.h") && \
    __has_include("Contracts/Settings/ISettingsParser.h") && \
    __has_include("Contracts/Providers/ISettingsProvider.h")

#define IOTSMARTSYS_HAS_SETTINGS_MANAGER 1

#include "Contracts/Settings/SettingsManager.h"
#include "Contracts/Settings/ISettingsFetcher.h"
#include "Contracts/Settings/ISettingsParser.h"
#include "Contracts/Providers/ISettingsProvider.h"

// Platform implementations (expected to be provided by ESP-IDF platform layer)
#if __has_include("Platform/Espressif/Settings/EspIdfSettingsFetcher.h")
#include "Platform/Espressif/Settings/EspIdfSettingsFetcher.h"
#endif
#if __has_include("Platform/Espressif/Settings/EspIdfSettingsParser.h")
#include "Platform/Espressif/Settings/EspIdfSettingsParser.h"
#endif
#if __has_include("Platform/Espressif/Settings/Providers/EspIdfNvsSettingsProvider.h")
#include "Platform/Espressif/Settings/Providers/EspIdfNvsSettingsProvider.h"
#endif

#else
#define IOTSMARTSYS_HAS_SETTINGS_MANAGER 0
#endif

using namespace iotsmartsys;

// Build-time macros expected for SettingsManager API refresh (define in platformio.ini build_flags):
//  - SETTINGS_API_URL
//  - API_KEY (optional)
//  - CLIENT_ID (optional)
//  - API_BASIC_AUTH (optional)

static platform::arduino::ArduinoSerialLogger logger(Serial);
static platform::arduino::ArduinoTimeProvider timeProvider;

static app::WiFiManager wifi(logger);

static platform::esp32::EspIdfMqttClient mqttClient(logger);
static app::MqttService<12, 16, 256> mqtt(mqttClient, logger);
static core::MqttSink *mqttSink = new core::MqttSink(mqttClient);

#if IOTSMARTSYS_HAS_SETTINGS_MANAGER
// NOTE: These objects are only created if the SettingsManager + platform implementations exist.
static iotsmartsys::platform::espressif::EspIdfSettingsFetcher settingsFetcher;
static iotsmartsys::platform::espressif::EspIdfSettingsParser settingsParser;
static iotsmartsys::platform::espressif::EspIdfNvsSettingsProvider settingsProvider;

static iotsmartsys::core::settings::SettingsManager settingsManager(
    settingsProvider,
    settingsFetcher,
    settingsParser);

// A small helper to apply Settings -> WiFi/MQTT runtime configs
static void applySettingsToRuntime(const iotsmartsys::core::settings::Settings &s)
{
    // WiFi
    app::WiFiConfig cfg;
    cfg.ssid = s.wifi.ssid.empty() ? WIFI_SSID : s.wifi.ssid.c_str();
    cfg.password = s.wifi.password.empty() ? WIFI_PASSWORD : s.wifi.password.c_str();
    cfg.initialBackoffMs = 1000;
    cfg.maxBackoffMs = 60000;
    cfg.jitterMs = 300;
    cfg.autoReconnect = false;
    cfg.persistent = false;

    logger.info("[SettingsManager] Applying WiFi settings. SSID=%s", cfg.ssid);
    wifi.begin(cfg);

    // MQTT
    core::MqttConfig mcfg;
    mcfg.clientId = "esp32s3-basic-usage";

    // Build URI from settings (protocol/host/port). Example: mqtt://192.168.0.222:1883
    // NOTE: If your MqttConfig already stores a full URI, replace this.
    static char uri[192];
    const char *proto = s.mqtt.primary.protocol.empty() ? "mqtt" : s.mqtt.primary.protocol.c_str();
    const char *host = s.mqtt.primary.host.empty() ? MQTT_BROKER : s.mqtt.primary.host.c_str();
    const int port = (s.mqtt.primary.port > 0) ? s.mqtt.primary.port : 1883;
    snprintf(uri, sizeof(uri), "%s://%s:%d", proto, host, port);

    mcfg.uri = uri;
    mcfg.username = s.mqtt.primary.user.empty() ? MQTT_USERNAME : s.mqtt.primary.user.c_str();
    mcfg.password = s.mqtt.primary.password.empty() ? MQTT_PASSWORD : s.mqtt.primary.password.c_str();
    mcfg.keepAliveSec = 30;
    mcfg.cleanSession = true;

    logger.info("[SettingsManager] Applying MQTT settings. URI=%s", mcfg.uri);
    mqtt.begin(mcfg);
}

static void onSettingsUpdated(const iotsmartsys::core::settings::Settings &newSettings, void *)
{
    logger.warn("[SettingsManager] Settings updated from API. Re-applying runtime config...");
    applySettingsToRuntime(newSettings);
}
#endif

static void onMqttMessage(void *, const core::MqttMessageView &msg)
{
    logger.warn("MQTT RX payload_len=%lu retain=%d",
                (unsigned long)msg.payloadLen,
                (int)msg.retain);
}
#define BUTTON_PIN ESP32_S3_GPIO0
#define LED_PIN PIN_TEST

platform::arduino::RelayHardwareAdapter relayAdapter(LED_PIN, platform::arduino::HardwareDigitalLogic::LOW_IS_ON);
core::LightCapability lightCap("living_room", relayAdapter, mqttSink);
platform::arduino::InputHardwareAdapter buttonAdapter(BUTTON_PIN, platform::arduino::HardwareDigitalLogic::LOW_IS_ON, platform::arduino::InputPullMode::UP);
core::PushButtonCapability buttonCap("button", buttonAdapter, mqttSink);
unsigned long lastButtonCheck = 0;
void simulatedButtonPress()
{
    buttonCap.handle();
    if (buttonCap.isPressed())
    {
        logger.info("Button pressed, LED state toggled.");
        lightCap.toggle();
        lastButtonCheck = millis();
        logger.info("LED is now %s", lightCap.isOn() ? "ON" : "OFF");
    }
    else
    {
        // logger.info("Button not pressed.");
    }
    if (millis() - lastButtonCheck > 5000 && lastButtonCheck != 0)
    {
        digitalWrite(43, !digitalRead(43));
        lastButtonCheck = millis();
    }

    lightCap.handle();

    delay(200); // debounce
}

void setup()
{
    Serial.begin(115200);
    delay(500); // esperar serial

    buttonAdapter.setup();
    relayAdapter.setup();

    Serial.println("[Serial] Starting IoT SmartSys Core example...");
    logger.setMinLevel(core::LogLevel::Debug);
    core::Log::setLogger(&logger);
    core::Time::setProvider(&timeProvider);
    logger.info("Logger and TimeProvider initialized.");

#if IOTSMARTSYS_HAS_SETTINGS_MANAGER
    settingsManager.setUpdatedCallback(&onSettingsUpdated, nullptr);

    // 1) Load from redundancy cache (NVS) if present
    const auto cacheErr = settingsManager.initLoadFromCache();
    if (cacheErr == iotsmartsys::core::common::Error::Ok)
    {
        iotsmartsys::core::settings::Settings cached;
        if (settingsManager.copyCurrent(cached))
        {
            logger.info("[SettingsManager] Loaded settings from NVS cache.");
            applySettingsToRuntime(cached);
        }
    }
    else
    {
        logger.warn("[SettingsManager] No cached settings found (or load failed). Using compile-time defaults until API refresh.");

        // Apply compile-time defaults immediately
        app::WiFiConfig cfg;
        cfg.ssid = WIFI_SSID;
        cfg.password = WIFI_PASSWORD;
        cfg.initialBackoffMs = 1000;
        cfg.maxBackoffMs = 60000;
        cfg.jitterMs = 300;
        cfg.autoReconnect = false;
        cfg.persistent = false;
        wifi.begin(cfg);

        core::MqttConfig mcfg;
        mcfg.clientId = "esp32s3-basic-usage";
        mcfg.uri = MQTT_BROKER;
        mcfg.username = MQTT_USERNAME;
        mcfg.password = MQTT_PASSWORD;
        mcfg.keepAliveSec = 30;
        mcfg.cleanSession = true;
        mqtt.begin(mcfg);
    }

    // 2) API is source of truth: refresh asynchronously (does not block firmware)
    iotsmartsys::core::settings::SettingsFetchRequest req;
    req.url = SETTINGS_API_URL; // define this macro in your env/build_flags

    // Optional headers (example). If you don't need them, leave empty.
    static iotsmartsys::core::settings::HttpHeader headers[] = {
        {"x-api-key", API_KEY},
        {"client_id", CLIENT_ID},
        {"Authorization", API_BASIC_AUTH},
    };
    req.headers = headers;
    req.headers_count = sizeof(headers) / sizeof(headers[0]);

    req.connect_timeout_ms = 3000;
    req.read_timeout_ms = 6000;
    req.max_body_bytes = 10 * 1024;
    req.max_attempts = 4;

    const auto startErr = settingsManager.refreshFromApiAsync(req);
    if (startErr == iotsmartsys::core::common::Error::Ok)
        logger.info("[SettingsManager] API refresh started.");
    else
        logger.warn("[SettingsManager] Failed to start API refresh.");

#else
    // ---- Fallback: compile-time WiFi + MQTT settings ----
    app::WiFiConfig cfg;
    cfg.ssid = WIFI_SSID;
    cfg.password = WIFI_PASSWORD;
    cfg.initialBackoffMs = 1000;
    cfg.maxBackoffMs = 60000;
    cfg.jitterMs = 300;
    cfg.autoReconnect = false;
    cfg.persistent = false;

    logger.warn("Basic_usageWiFi configuration set. SSID: %s", cfg.ssid);
    wifi.begin(cfg);

    logger.info("Configuring MQTT client...");
    core::MqttConfig mcfg;
    mcfg.clientId = "esp32s3-basic-usage";
    mcfg.uri = MQTT_BROKER;
    mcfg.username = MQTT_USERNAME;
    mcfg.password = MQTT_PASSWORD;
    mcfg.keepAliveSec = 30;
    mcfg.cleanSession = true;

    logger.info("Starting MQTT client...");
    mqtt.begin(mcfg);
    logger.info("MQTT client started.");
#endif

    mqtt.setOnMessage(&onMqttMessage, nullptr);
    logger.info("MQTT message handler set.");
    mqtt.subscribe("iotsmartsys/cmd/#");
    logger.info("MQTT client subscribed to topic.");
}

void loop()
{
    simulatedButtonPress();
    wifi.handle();
    mqtt.handle();

    static uint32_t last = 0;
    const uint32_t now = (uint32_t)timeProvider.nowMs();
    if (now - last >= 5000)
    {
        last = now;
        const char payload[] = "{\"alive\":true}";
        mqtt.publish("iotsmartsys/state/alive", payload, sizeof(payload) - 1, false);

        // Log status occasionally (not every loop)
        if (wifi.isConnected())
        {
            logger.info("WiFi OK IP=%s MQTT=%s",
                        WiFi.localIP().toString().c_str(),
                        mqtt.isOnline() ? "online" : "offline");
        }
        else
        {
            logger.warn("WiFi down state=%s MQTT=%s",
                        wifi.stateName(),
                        mqtt.isOnline() ? "online" : "offline");
        }
    }

    delay(2);
}
#endif